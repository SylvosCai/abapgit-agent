#!/usr/bin/env node
/**
 * ABAP Git Agent - CLI Tool
 *
 * Usage:
 *   abapgit-agent init --folder <folder> --package <package>
 *   abapgit-agent create
 *   abapgit-agent import [--message <message>]
 *   abapgit-agent pull [--branch <branch>]
 *   abapgit-agent pull --url <git-url> [--branch <branch>]
 *   abapgit-agent health
 *   abapgit-agent status
 *
 * Auto-detects git remote URL and branch from current directory.
 */

const pathModule = require('path');
const fs = require('fs');

// Get terminal width for responsive table
const getTermWidth = () => process.stdout.columns || 80;
const TERM_WIDTH = getTermWidth();

const COOKIE_FILE = '.abapgit_agent_cookies.txt';

/**
 * Load configuration from .abapGitAgent in current working directory
 */
function loadConfig() {
  const repoConfigPath = pathModule.join(process.cwd(), '.abapGitAgent');

  if (fs.existsSync(repoConfigPath)) {
    return JSON.parse(fs.readFileSync(repoConfigPath, 'utf8'));
  }

  // Fallback to environment variables
  return {
    host: process.env.ABAP_HOST,
    sapport: parseInt(process.env.ABAP_PORT, 10) || 443,
    client: process.env.ABAP_CLIENT || '100',
    user: process.env.ABAP_USER,
    password: process.env.ABAP_PASSWORD,
    language: process.env.ABAP_LANGUAGE || 'EN',
    gitUsername: process.env.GIT_USERNAME,
    gitPassword: process.env.GIT_PASSWORD
  };
}

/**
 * Check if ABAP integration is configured for this repo
 */
function isAbapIntegrationEnabled() {
  const repoConfigPath = pathModule.join(process.cwd(), '.abapGitAgent');
  return fs.existsSync(repoConfigPath);
}

/**
 * Get git remote URL from .git/config
 */
function getGitRemoteUrl() {
  const gitConfigPath = pathModule.join(process.cwd(), '.git', 'config');

  if (!fs.existsSync(gitConfigPath)) {
    return null;
  }

  const content = fs.readFileSync(gitConfigPath, 'utf8');
  const remoteMatch = content.match(/\[remote "origin"\]/);

  if (!remoteMatch) {
    return null;
  }

  const urlMatch = content.match(/	url = (.+)/);
  return urlMatch ? urlMatch[1].trim() : null;
}

/**
 * Get current git branch
 */
function getGitBranch() {
  const headPath = pathModule.join(process.cwd(), '.git', 'HEAD');

  if (!fs.existsSync(headPath)) {
    return 'main';
  }

  const content = fs.readFileSync(headPath, 'utf8').trim();
  const match = content.match(/ref: refs\/heads\/(.+)/);
  return match ? match[1] : 'main';
}

/**
 * Read cookies from file
 * Supports both Netscape format and simple cookie string format
 */
function readNetscapeCookies() {
  const cookiePath = pathModule.join(process.cwd(), COOKIE_FILE);
  if (!fs.existsSync(cookiePath)) return '';

  const content = fs.readFileSync(cookiePath, 'utf8').trim();
  if (!content) return '';

  // Check if it's Netscape format (has tabs)
  if (content.includes('\t')) {
    const lines = content.split('\n');
    const cookies = [];

    for (const line of lines) {
      const trimmed = line.trim();
      if (!trimmed || (trimmed.startsWith('#') && !trimmed.startsWith('#HttpOnly'))) continue;

      const parts = trimmed.split('\t');
      if (parts.length >= 7) {
        cookies.push(`${parts[5]}=${parts[6]}`);
      }
    }

    return cookies.join('; ');
  }

  // Simple format - just return as-is
  return content;
}

/**
 * Save cookies to Netscape format cookie file
 */
function saveCookies(cookies, host) {
  const cookiePath = pathModule.join(process.cwd(), COOKIE_FILE);

  // Parse cookies and convert to Netscape format
  const cookieList = cookies.split(';').map(c => c.trim()).filter(Boolean);
  const lines = ['# Netscape HTTP Cookie File', '# https://curl.se/docs/http-cookies.html', '# This file was generated by libcurl! Edit at your own risk.'];

  for (const cookie of cookieList) {
    const [name, ...valueParts] = cookie.split('=');
    const value = valueParts.join('=');

    // HttpOnly cookies get #HttpOnly_ prefix
    const domain = name.includes('SAP') || name.includes('MYSAP') || name.includes('SAPLOGON')
      ? `#HttpOnly_${host}`
      : host;

    // Format: domain, flag, path, secure, expiration, name, value
    lines.push(`${domain}\tFALSE\t/\tFALSE\t0\t${name.trim()}\t${value}`);
  }

  fs.writeFileSync(cookiePath, lines.join('\n'));
}

/**
 * Fetch CSRF token using GET /health with X-CSRF-Token: fetch
 */
async function fetchCsrfToken(config) {
  const https = require('https');
  const url = new URL(`/sap/bc/z_abapgit_agent/health`, `https://${config.host}:${config.sapport}`);

  return new Promise((resolve, reject) => {
    // Clear stale cookies before fetching new token
    const cookiePath = pathModule.join(process.cwd(), COOKIE_FILE);
    if (fs.existsSync(cookiePath)) {
      fs.unlinkSync(cookiePath);
    }

    const cookieHeader = readNetscapeCookies();

    const options = {
      hostname: url.hostname,
      port: url.port,
      path: url.pathname,
      method: 'GET',
      headers: {
        'Authorization': `Basic ${Buffer.from(`${config.user}:${config.password}`).toString('base64')}`,
        'sap-client': config.client,
        'sap-language': config.language || 'EN',
        'X-CSRF-Token': 'fetch',
        'Content-Type': 'application/json',
        ...(cookieHeader && { 'Cookie': cookieHeader })
      },
      agent: new https.Agent({ rejectUnauthorized: false })
    };

    const req = https.request(options, (res) => {
      const csrfToken = res.headers['x-csrf-token'];

      // Save new cookies from response
      const setCookie = res.headers['set-cookie'];
      if (setCookie) {
        const cookies = Array.isArray(setCookie)
          ? setCookie.map(c => c.split(';')[0]).join('; ')
          : setCookie.split(';')[0];
        saveCookies(cookies, config.host);
      }

      let body = '';
      res.on('data', chunk => body += chunk);
      res.on('end', () => {
        resolve(csrfToken);
      });
    });

    req.on('error', reject);
    req.end();
  });
}

/**
 * Make HTTP request to ABAP REST endpoint
 */
function request(method, urlPath, data = null, options = {}) {
  return new Promise((resolve, reject) => {
    const https = require('https');
    const http = require('http');
    const config = loadConfig();
    const url = new URL(urlPath, `https://${config.host}:${config.sapport}`);

    const headers = {
      'Content-Type': 'application/json',
      'sap-client': config.client,
      'sap-language': config.language || 'EN',
      ...options.headers
    };

    // Add authorization
    headers['Authorization'] = `Basic ${Buffer.from(`${config.user}:${config.password}`).toString('base64')}`;

    // Add CSRF token for POST
    if (method === 'POST' && options.csrfToken) {
      headers['X-CSRF-Token'] = options.csrfToken;
    }

    // Add cookies if available
    const cookieHeader = readNetscapeCookies();
    if (cookieHeader) {
      headers['Cookie'] = cookieHeader;
    }

    const reqOptions = {
      hostname: url.hostname,
      port: url.port,
      path: url.pathname,
      method,
      headers,
      agent: new https.Agent({ rejectUnauthorized: false })
    };

    const req = (url.protocol === 'https:' ? https : http).request(reqOptions, (res) => {
      let body = '';
      res.on('data', chunk => body += chunk);
      res.on('end', () => {
        try {
          // Handle unescaped newlines from ABAP - replace actual newlines with \n
          const cleanedBody = body.replace(/\n/g, '\\n');
          resolve(JSON.parse(cleanedBody));
        } catch (e) {
          // Fallback: try to extract JSON from response
          const jsonMatch = body.match(/\{[\s\S]*\}/);
          if (jsonMatch) {
            try {
              resolve(JSON.parse(jsonMatch[0].replace(/\n/g, '\\n')));
            } catch (e2) {
              resolve({ raw: body, error: e2.message });
            }
          } else {
            resolve({ raw: body, error: e.message });
          }
        }
      });
    });

    req.on('error', reject);

    if (data) {
      req.write(JSON.stringify(data));
    }
    req.end();
  });
}

/**
 * Inspect ABAP source file
 * Reads file content and sends to /inspect
 */
async function syntaxCheckSource(sourceFile, csrfToken, config) {
  console.log(`  Syntax check for file: ${sourceFile}`);

  try {
    // Read file content
    const absolutePath = pathModule.isAbsolute(sourceFile)
      ? sourceFile
      : pathModule.join(process.cwd(), sourceFile);

    if (!fs.existsSync(absolutePath)) {
      console.error(`  ‚ùå File not found: ${absolutePath}`);
      return;
    }

    const fileContent = fs.readFileSync(absolutePath, 'utf8');

    // Extract source name from file path (basename with extension)
    // e.g., "zcl_my_class.clas.abap" -> "ZCL_MY_CLASS.CLASS.ABAP"
    const sourceName = pathModule.basename(sourceFile).toUpperCase();

    // Send files array to syntax-check endpoint
    const data = {
      files: [sourceName]
    };

    const result = await request('POST', '/sap/bc/z_abapgit_agent/inspect', data, { csrfToken: csrfToken });

    // Handle uppercase keys from ABAP - handle both 'X'/true (success) and false
    const success = result.SUCCESS !== undefined ? result.SUCCESS : (result.success !== undefined ? result.success : null);
    const errorCount = result.ERROR_COUNT || result.error_count || 0;
    const errors = result.ERRORS || result.errors || [];

    console.log('\n');

    if (errorCount > 0) {
      console.log(`‚ùå Syntax check failed (${errorCount} error(s)):`);
      console.log('\nErrors:');
      console.log('‚îÄ'.repeat(60));

      for (const err of errors) {
        const line = err.LINE || err.line || '?';
        const column = err.COLUMN || err.column || '?';
        const text = err.TEXT || err.text || 'Unknown error';

        console.log(`  Line ${line}, Column ${column}:`);
        console.log(`    ${text}`);
        console.log('');
      }
    } else if (success === 'X' || success === true) {
      console.log(`‚úÖ ${pathModule.basename(sourceFile)} - Syntax check passed (0 errors)`);
    } else if (success === false) {
      console.log(`‚ùå ${pathModule.basename(sourceFile)} - Syntax check failed`);
    } else {
      console.log(`‚ö†Ô∏è  Syntax check returned unexpected status: ${success}`);
    }

    return result;
  } catch (error) {
    console.error(`\n  Error: ${error.message}`);
    process.exit(1);
  }
}

/**
 * Run unit tests for package or objects
 */
async function runUnitTests(options) {
  console.log('\n  Running unit tests');

  try {
    const config = loadConfig();

    // Fetch CSRF token first
    const csrfToken = await fetchCsrfToken(config);

    const data = {};

    if (options.package) {
      data.package = options.package;
    }

    if (options.objects && options.objects.length > 0) {
      data.objects = options.objects;
    }

    const result = await request('POST', '/sap/bc/z_abapgit_agent/unit', data, { csrfToken });

    // Display raw result for debugging
    if (process.env.DEBUG) {
      console.log('Raw result:', JSON.stringify(result, null, 2));
    }

    // Handle uppercase keys from ABAP
    const success = result.SUCCESS || result.success;
    const testCount = result.TEST_COUNT || result.test_count || 0;
    const passedCount = result.PASSED_COUNT || result.passed_count || 0;
    const failedCount = result.FAILED_COUNT || result.failed_count || 0;
    const message = result.MESSAGE || result.message || '';
    const errors = result.ERRORS || result.errors || [];

    console.log('\n');

    if (success === 'X' || success === true) {
      console.log(`‚úÖ All tests passed!`);
    } else {
      console.log(`‚ùå Some tests failed`);
    }

    console.log(`   ${message}`);
    console.log(`   Tests: ${testCount} | Passed: ${passedCount} | Failed: ${failedCount}`);

    if (failedCount > 0 && errors.length > 0) {
      console.log('\nFailed Tests:');
      console.log('‚îÄ'.repeat(60));

      for (const err of errors) {
        const className = err.CLASS_NAME || err.class_name || '?';
        const methodName = err.METHOD_NAME || err.method_name || '?';
        const errorKind = err.ERROR_KIND || err.error_kind || '';
        const errorText = err.ERROR_TEXT || err.error_text || 'Unknown error';

        console.log(`   ‚úó ${className}=>${methodName}`);
        if (errorKind) {
          console.log(`     Kind: ${errorKind}`);
        }
        console.log(`     Error: ${errorText}`);
        console.log('');
      }
    }

    return result;
  } catch (error) {
    console.error(`\n  Error: ${error.message}`);
    process.exit(1);
  }
}

/**
 * Run unit test for a single file
 */
async function runUnitTestForFile(sourceFile, csrfToken, config) {
  console.log(`  Running unit test for: ${sourceFile}`);

  try {
    // Read file content
    const absolutePath = pathModule.isAbsolute(sourceFile)
      ? sourceFile
      : pathModule.join(process.cwd(), sourceFile);

    if (!fs.existsSync(absolutePath)) {
      console.error(`  ‚ùå File not found: ${absolutePath}`);
      return;
    }

    // Extract object type and name from file path
    // e.g., "zcl_my_test.clas.abap" -> CLAS, ZCL_MY_TEST
    const fileName = pathModule.basename(sourceFile).toUpperCase();
    const parts = fileName.split('.');
    if (parts.length < 3) {
      console.error(`  ‚ùå Invalid file format: ${sourceFile}`);
      return;
    }

    // obj_name is first part (may contain path), obj_type is second part
    const objType = parts[1] === 'CLASS' ? 'CLAS' : parts[1];
    let objName = parts[0];

    // Handle subdirectory paths
    const lastSlash = objName.lastIndexOf('/');
    if (lastSlash >= 0) {
      objName = objName.substring(lastSlash + 1);
    }

    // Send files array to unit endpoint (ABAP expects string_table of file names)
    const data = {
      files: [sourceFile]
    };

    const result = await request('POST', '/sap/bc/z_abapgit_agent/unit', data, { csrfToken });

    // Handle uppercase keys from ABAP
    const success = result.SUCCESS || result.success;
    const testCount = result.TEST_COUNT || result.test_count || 0;
    const passedCount = result.PASSED_COUNT || result.passed_count || 0;
    const failedCount = result.FAILED_COUNT || result.failed_count || 0;
    const message = result.MESSAGE || result.message || '';
    const errors = result.ERRORS || result.errors || [];

    if (testCount === 0) {
      console.log(`  ‚ûñ ${objName} - No unit tests`);
    } else if (success === 'X' || success === true) {
      console.log(`  ‚úÖ ${objName} - All tests passed`);
    } else {
      console.log(`  ‚ùå ${objName} - Tests failed`);
    }

    console.log(`     Tests: ${testCount} | Passed: ${passedCount} | Failed: ${failedCount}`);

    if (failedCount > 0 && errors.length > 0) {
      for (const err of errors) {
        const className = err.CLASS_NAME || err.class_name || '?';
        const methodName = err.METHOD_NAME || err.method_name || '?';
        const errorText = err.ERROR_TEXT || err.error_text || 'Unknown error';
        console.log(`     ‚úó ${className}=>${methodName}: ${errorText}`);
      }
    }

    return result;
  } catch (error) {
    console.error(`\n  Error: ${error.message}`);
  }
}

/**
 * Run tree command and return raw result
 */
async function runTreeCommand(packageName, depth, includeObjects, csrfToken, config) {
  const data = {
    package: packageName,
    depth: depth,
    include_objects: includeObjects
  };

  return await request('POST', '/sap/bc/z_abapgit_agent/tree', data, { csrfToken });
}

/**
 * Display tree output in human-readable format with AI metadata
 */
async function displayTreeOutput(packageName, depth, includeObjects) {
  const config = loadConfig();
  const csrfToken = await fetchCsrfToken(config);

  console.log(`\n  Getting package tree for: ${packageName}`);

  const result = await runTreeCommand(packageName, depth, includeObjects, csrfToken, config);

  // Handle uppercase keys from ABAP
  const success = result.SUCCESS || result.success;
  const error = result.ERROR || result.error;

  if (!success || error) {
    console.error(`\n  ‚ùå Error: ${error || 'Failed to get tree'}`);
    return;
  }

  // Parse hierarchy structure (ABAP returns flat nodes with parent refs)
  const nodes = result.NODES || result.nodes || [];
  const rootPackage = result.PACKAGE || result.package || packageName;
  const parentPackage = result.PARENT_PACKAGE || result.parent_package;
  const totalPackages = result.TOTAL_PACKAGES || result.total_packages || 0;
  const totalObjects = result.TOTAL_OBJECTS || result.total_objects || 0;
  const objectTypes = result.OBJECTS || result.objects || [];

  console.log(`\n  Package Tree: ${rootPackage}`);

  // Display parent info if available
  if (parentPackage && parentPackage !== rootPackage) {
    console.log(`  ‚¨ÜÔ∏è  Parent: ${parentPackage}`);
  }

  console.log('');

  // Build and display tree from flat nodes list
  const lines = buildTreeLinesFromNodes(nodes, '', true);
  for (const line of lines) {
    console.log(`  ${line}`);
  }

  console.log('');
  console.log('  Summary');
  console.log(`  PACKAGES: ${totalPackages}`);
  console.log(`  OBJECTS: ${totalObjects}`);

  // Display object types if available
  if (includeObjects && objectTypes.length > 0) {
    const typeStr = objectTypes.map(t => `${t.OBJECT || t.object}=${t.COUNT || t.count}`).join(' ');
    console.log(`  TYPES: ${typeStr}`);
  }

  // AI metadata block
  const aiMetadata = {
    package: rootPackage,
    parent: parentPackage || null,
    total_packages: totalPackages,
    total_objects: totalObjects,
    types: {}
  };

  objectTypes.forEach(t => {
    const key = t.OBJECT || t.object;
    const count = t.COUNT || t.count;
    if (key) {
      aiMetadata.types[key] = count;
    }
  });

  console.log('');
  console.log(`<!-- AI_METADATA_START -->${JSON.stringify(aiMetadata)}<!-- AI_METADATA_END -->`);
}

/**
 * Build tree display lines from flat nodes list
 */
function buildTreeLinesFromNodes(nodes, prefix, isLast) {
  const lines = [];

  if (nodes.length === 0) {
    return lines;
  }

  // First node is the root
  const root = nodes[0];
  const icon = 'üì¶';
  lines.push(`${prefix}${isLast ? '‚îî‚îÄ ' : '‚îú‚îÄ '} ${icon} ${root.PACKAGE || root.package}`);

  // Get children (nodes with depth > 0, grouped by depth)
  const children = nodes.filter(n => (n.DEPTH || n.depth) > 0);

  // Group children by depth
  const byDepth = {};
  children.forEach(n => {
    const d = n.DEPTH || n.depth;
    if (!byDepth[d]) byDepth[d] = [];
    byDepth[d].push(n);
  });

  // Process depth 1 children
  const depth1 = byDepth[1] || [];
  const newPrefix = prefix + (isLast ? '   ' : '‚îÇ  ');

  for (let i = 0; i < depth1.length; i++) {
    const child = depth1[i];
    const isSubLast = i === depth1.length - 1;
    const childLines = buildChildLines(child, newPrefix, isSubLast, byDepth);
    lines.push(...childLines);
  }

  return lines;
}

function buildChildLines(node, prefix, isLast, byDepth) {
  const lines = [];
  const icon = 'üì¶';
  lines.push(`${prefix}${isLast ? '‚îî‚îÄ ' : '‚îú‚îÄ '} ${icon} ${node.PACKAGE || node.package}`);

  const newPrefix = prefix + (isLast ? '   ' : '‚îÇ  ');
  const nodeDepth = node.DEPTH || node.depth;
  const children = byDepth[nodeDepth + 1] || [];

  // Find children of this node
  const myChildren = children.filter(n => (n.PARENT || n.parent) === (node.PACKAGE || node.package));

  for (let i = 0; i < myChildren.length; i++) {
    const child = myChildren[i];
    const isSubLast = i === myChildren.length - 1;
    const childLines = buildChildLines(child, newPrefix, isSubLast, byDepth);
    lines.push(...childLines);
  }

  return lines;
}

/**
 * Pull and activate repository
 */
async function pull(gitUrl, branch = 'main', files = null, transportRequest = null) {
  console.log(`\nüöÄ Starting pull for: ${gitUrl}`);
  console.log(`   Branch: ${branch}`);
  if (files && files.length > 0) {
    console.log(`   Files: ${files.join(', ')}`);
  }
  if (transportRequest) {
    console.log(`   Transport Request: ${transportRequest}`);
  }

  try {
    const config = loadConfig();

    // Fetch CSRF token first
    const csrfToken = await fetchCsrfToken(config);

    // Prepare request data with git credentials
    const data = {
      url: gitUrl,
      branch: branch,
      username: config.gitUsername,
      password: config.gitPassword
    };

    // Add files array if specified
    if (files && files.length > 0) {
      data.files = files;
    }

    // Add transport request if specified
    if (transportRequest) {
      data.transport_request = transportRequest;
    }

    const result = await request('POST', '/sap/bc/z_abapgit_agent/pull', data, { csrfToken });

    console.log('\n');

    // Display raw result for debugging
    if (process.env.DEBUG) {
      console.log('Raw result:', JSON.stringify(result, null, 2));
    }

    // Handle uppercase keys from ABAP
    const success = result.SUCCESS || result.success;
    const jobId = result.JOB_ID || result.job_id;
    const message = result.MESSAGE || result.message;
    const errorDetail = result.ERROR_DETAIL || result.error_detail;
    const transportRequestUsed = result.TRANSPORT_REQUEST || result.transport_request;
    const activatedCount = result.ACTIVATED_COUNT || result.activated_count || 0;
    const failedCount = result.FAILED_COUNT || result.failed_count || 0;
    const logMessages = result.LOG_MESSAGES || result.log_messages || [];
    const activatedObjects = result.ACTIVATED_OBJECTS || result.activated_objects || [];
    const failedObjects = result.FAILED_OBJECTS || result.failed_objects || [];

    // Icon mapping for message types
    const getIcon = (type) => {
      const icons = {
        'S': '‚úÖ',  // Success
        'E': '‚ùå',  // Error
        'W': '‚ö†Ô∏è',  // Warning
        'A': 'üõë'   // Abort
      };
      return icons[type] || '  ';
    };

    if (success === 'X' || success === true) {
      console.log(`‚úÖ Pull completed successfully!`);
      console.log(`   Job ID: ${jobId || 'N/A'}`);
      console.log(`   Message: ${message || 'N/A'}`);
    } else {
      console.log(`‚ùå Pull completed with errors!`);
      console.log(`   Job ID: ${jobId || 'N/A'}`);
      console.log(`   Message: ${message || 'N/A'}`);
    }

    // Display error detail if available
    if (errorDetail && errorDetail.trim()) {
      console.log(`\nüìã Error Details:`);
      console.log('‚îÄ'.repeat(TERM_WIDTH));
      // Handle escaped newlines from ABAP JSON
      const formattedDetail = errorDetail.replace(/\\n/g, '\n');
      console.log(formattedDetail);
    }

    // Display all messages as table (from log_messages)
    if (logMessages && logMessages.length > 0) {
      console.log(`\nüìã Pull Log (${logMessages.length} messages):`);

      // Calculate column widths based on terminal width
      const tableWidth = Math.min(TERM_WIDTH, 120);
      const iconCol = 5;  // Width for emoji column (emoji takes 2 visual cells)
      const objCol = 28;
      const msgCol = tableWidth - iconCol - objCol - 6; // Account for vertical lines (3 chars)

      // Helper to get visible width (emoji takes 2 cells)
      const getVisibleWidth = (str) => {
        let width = 0;
        for (const char of str) {
          width += (char.charCodeAt(0) > 127) ? 2 : 1;  // Emoji/wide chars = 2
        }
        return width;
      };

      // Helper to pad to visible width
      const padToWidth = (str, width) => {
        const currentWidth = getVisibleWidth(str);
        return str + ' '.repeat(width - currentWidth);
      };

      const headerLine = '‚îÄ'.repeat(iconCol) + '‚îº' + '‚îÄ'.repeat(objCol) + '‚îº' + '‚îÄ'.repeat(msgCol);
      const headerText = padToWidth('Icon', iconCol) + '‚îÇ' + padToWidth('Object', objCol) + '‚îÇ' + 'Message'.substring(0, msgCol);
      const borderLine = '‚îÄ'.repeat(tableWidth);

      console.log(borderLine);
      console.log(headerText);
      console.log(headerLine);

      for (const msg of logMessages) {
        const icon = getIcon(msg.TYPE);
        const objType = msg.OBJ_TYPE || '';
        const objName = msg.OBJ_NAME || '';
        const obj = objType && objName ? `${objType} ${objName}` : '';
        const text = msg.TEXT || '';

        // Truncate long text
        const displayText = text.length > msgCol ? text.substring(0, msgCol - 3) + '...' : text;

        console.log(padToWidth(icon, iconCol) + '‚îÇ' + padToWidth(obj.substring(0, objCol), objCol) + '‚îÇ' + displayText);
      }
    }

    // Extract objects with errors from log messages (type 'E' = Error)
    const failedObjectsFromLog = [];
    const objectsWithErrors = new Set();

    for (const msg of logMessages) {
      if (msg.TYPE === 'E' && msg.OBJ_TYPE && msg.OBJ_NAME) {
        const objKey = `${msg.OBJ_TYPE} ${msg.OBJ_NAME}`;
        objectsWithErrors.add(objKey);
        failedObjectsFromLog.push({
          OBJ_TYPE: msg.OBJ_TYPE,
          OBJ_NAME: msg.OBJ_NAME,
          TEXT: msg.TEXT || 'Activation failed',
          EXCEPTION: msg.EXCEPTION || ''
        });
      }
    }

    // Filter activated objects - only include objects without errors
    const filteredActivatedObjects = activatedObjects.filter(obj => {
      const objKey = obj.OBJ_TYPE && obj.OBJ_NAME ? `${obj.OBJ_TYPE} ${obj.OBJ_NAME}` : '';
      return objKey && !objectsWithErrors.has(objKey);
    });

    // Display unique activated objects (excluding objects with errors)
    if (filteredActivatedObjects && filteredActivatedObjects.length > 0) {
      console.log(`\nüì¶ Activated Objects (${filteredActivatedObjects.length}):`);
      console.log('‚îÄ'.repeat(TERM_WIDTH));
      for (const obj of filteredActivatedObjects) {
        console.log(`‚úÖ ${obj.OBJ_TYPE} ${obj.OBJ_NAME}`);
      }
    }

    // Display failed objects log (all error messages, duplicates allowed)
    if (failedObjectsFromLog.length > 0) {
      console.log(`\n‚ùå Failed Objects Log (${failedObjectsFromLog.length} entries):`);
      console.log('‚îÄ'.repeat(TERM_WIDTH));
      for (const obj of failedObjectsFromLog) {
        const objKey = obj.OBJ_TYPE && obj.OBJ_NAME ? `${obj.OBJ_TYPE} ${obj.OBJ_NAME}` : '';
        let text = obj.TEXT || 'Activation failed';
        // Include exception text if available
        if (obj.EXCEPTION && obj.EXCEPTION.trim()) {
          text = `${text}\nException: ${obj.EXCEPTION}`;
        }
        console.log(`‚ùå ${objKey}: ${text}`);
      }
    } else if (failedObjects && failedObjects.length > 0) {
      // Fallback to API failed_objects if no errors in log
      console.log(`\n‚ùå Failed Objects Log (${failedObjects.length}):`);
      console.log('‚îÄ'.repeat(TERM_WIDTH));
      for (const obj of failedObjects) {
        const objKey = obj.OBJ_TYPE && obj.OBJ_NAME ? `${obj.OBJ_TYPE} ${obj.OBJ_NAME}` : '';
        let text = obj.TEXT || 'Activation failed';
        // Include exception text if available
        if (obj.EXCEPTION && obj.EXCEPTION.trim()) {
          text = `${text}\nException: ${obj.EXCEPTION}`;
        }
        console.log(`‚ùå ${objKey}: ${text}`);
      }
    } else if (failedCount > 0) {
      console.log(`\n‚ùå Failed Objects Log (${failedCount})`);
    }

    return result;
  } catch (error) {
    console.error(`\n‚ùå Error: ${error.message}`);
    process.exit(1);
  }
}

/**
 * Run init command - Initialize local configuration
 */
async function runInit(args) {
  const folderArgIndex = args.indexOf('--folder');
  const packageArgIndex = args.indexOf('--package');

  // Get parameters
  const folder = folderArgIndex !== -1 && folderArgIndex + 1 < args.length
    ? args[folderArgIndex + 1]
    : '/src/';

  const packageName = packageArgIndex !== -1 && packageArgIndex + 1 < args.length
    ? args[packageArgIndex + 1]
    : null;

  // Validate package is required
  if (!packageName) {
    console.error('Error: --package is required');
    console.error('Usage: abapgit-agent init --folder /src --package ZMY_PACKAGE');
    process.exit(1);
  }

  console.log(`\nüöÄ Initializing abapGit Agent for local repository`);
  console.log(`   Folder: ${folder}`);
  console.log(`   Package: ${packageName}`);
  console.log('');

  // Check if current folder is git repo root
  const gitDir = pathModule.join(process.cwd(), '.git');
  if (!fs.existsSync(gitDir)) {
    console.error('Error: Current folder is not a git repository.');
    console.error('Run this command from the root folder of your git repository.');
    process.exit(1);
  }

  // Detect git remote URL
  const gitUrl = getGitRemoteUrl();
  if (!gitUrl) {
    console.error('Error: No git remote configured.');
    console.error('Configure a remote with: git remote add origin <url>');
    process.exit(1);
  }
  console.log(`üìå Git remote: ${gitUrl}`);

  // Check if .abapGitAgent already exists
  const configPath = pathModule.join(process.cwd(), '.abapGitAgent');
  if (fs.existsSync(configPath)) {
    console.error('Error: .abapGitAgent already exists.');
    console.error('To reinitialize, delete the existing file first.');
    process.exit(1);
  }

  // Copy .abapGitAgent.example to .abapGitAgent
  const samplePath = pathModule.join(__dirname, '..', '.abapGitAgent.example');
  if (!fs.existsSync(samplePath)) {
    console.error('Error: .abapGitAgent.example not found.');
    process.exit(1);
  }

  try {
    // Read sample and update with package/folder
    const sampleContent = fs.readFileSync(samplePath, 'utf8');
    const config = JSON.parse(sampleContent);
    config.package = packageName;
    config.folder = folder;

    // Write updated config
    fs.writeFileSync(configPath, JSON.stringify(config, null, 2) + '\n');
    console.log(`‚úÖ Created .abapGitAgent`);
  } catch (error) {
    console.error(`Error creating .abapGitAgent: ${error.message}`);
    process.exit(1);
  }

  // Update .gitignore
  const gitignorePath = pathModule.join(process.cwd(), '.gitignore');
  const ignoreEntries = ['.abapGitAgent', '.abapgit_agent_cookies.txt'];
  let existingIgnore = '';

  if (fs.existsSync(gitignorePath)) {
    existingIgnore = fs.readFileSync(gitignorePath, 'utf8');
  }

  let updated = false;
  let newIgnoreContent = existingIgnore;

  for (const entry of ignoreEntries) {
    if (!newIgnoreContent.includes(entry)) {
      if (newIgnoreContent && !newIgnoreContent.endsWith('\n')) {
        newIgnoreContent += '\n';
      }
      newIgnoreContent += entry + '\n';
      updated = true;
    }
  }

  if (updated) {
    fs.writeFileSync(gitignorePath, newIgnoreContent);
    console.log(`‚úÖ Updated .gitignore`);
  } else {
    fs.writeFileSync(gitignorePath, newIgnoreContent);
    console.log(`‚úÖ .gitignore already up to date`);
  }

  // Copy CLAUDE.md
  const claudeMdPath = pathModule.join(__dirname, '..', 'abap', 'CLAUDE.md');
  const localClaudeMdPath = pathModule.join(process.cwd(), 'CLAUDE.md');
  try {
    if (fs.existsSync(claudeMdPath)) {
      fs.copyFileSync(claudeMdPath, localClaudeMdPath);
      console.log(`‚úÖ Created CLAUDE.md`);
    } else {
      console.log(`‚ö†Ô∏è  CLAUDE.md not found in abap/ directory`);
    }
  } catch (error) {
    console.error(`Error copying CLAUDE.md: ${error.message}`);
  }

  // Copy copilot-instructions.md for GitHub Copilot
  const copilotMdPath = pathModule.join(__dirname, '..', 'abap', 'copilot-instructions.md');
  const githubDir = pathModule.join(process.cwd(), '.github');
  const localCopilotMdPath = pathModule.join(githubDir, 'copilot-instructions.md');
  try {
    if (fs.existsSync(copilotMdPath)) {
      // Ensure .github directory exists
      if (!fs.existsSync(githubDir)) {
        fs.mkdirSync(githubDir, { recursive: true });
      }
      fs.copyFileSync(copilotMdPath, localCopilotMdPath);
      console.log(`‚úÖ Created .github/copilot-instructions.md`);
    } else {
      console.log(`‚ö†Ô∏è  copilot-instructions.md not found in abap/ directory`);
    }
  } catch (error) {
    console.error(`Error copying copilot-instructions.md: ${error.message}`);
  }

  // Create folder
  const folderPath = pathModule.join(process.cwd(), folder);
  try {
    if (!fs.existsSync(folderPath)) {
      fs.mkdirSync(folderPath, { recursive: true });
      console.log(`‚úÖ Created folder: ${folder}`);

      // Create .gitkeep
      const gitkeepPath = pathModule.join(folderPath, '.gitkeep');
      fs.writeFileSync(gitkeepPath, '');
    } else {
      console.log(`‚úÖ Folder already exists: ${folder}`);
    }
  } catch (error) {
    console.error(`Error creating folder: ${error.message}`);
  }

  console.log(`
üìã Next steps:
   1. Edit .abapGitAgent with your ABAP credentials (host, user, password)
   2. Run 'abapgit-agent create --import' to create online repository
   3. Run 'abapgit-agent pull' to activate objects
`);
}

/**
 * Check agent health
 */
async function healthCheck() {
  try {
    const result = await request('GET', '/sap/bc/z_abapgit_agent/health');
    console.log(JSON.stringify(result, null, 2));
    return result;
  } catch (error) {
    console.error(`Health check failed: ${error.message}`);
    process.exit(1);
  }
}

/**
 * Main CLI
 */
async function main() {
  const args = process.argv.slice(2);
  const command = args[0];

  // Check if ABAP integration is enabled for this repo
  // (skip for init, help commands)
  if (command && command !== 'init' && command !== 'help' && command !== '--help' && command !== '-h') {
    if (!isAbapIntegrationEnabled()) {
      console.log(`
‚ö†Ô∏è  ABAP Git Agent not configured for this repository.

To enable integration:
1. Create a .abapGitAgent file in the repo root with ABAP connection details:
{
  "host": "your-sap-system.com",
  "sapport": 443,
  "client": "100",
  "user": "TECH_USER",
  "password": "your-password",
  "language": "EN"
}

2. Or set environment variables:
   - ABAP_HOST, ABAP_PORT, ABAP_CLIENT, ABAP_USER, ABAP_PASSWORD
`);
      process.exit(1);
    }
  }

  try {
    switch (command) {
      case 'init':
        await runInit(args);
        return;  // Don't check ABAP integration for init

      case 'create': {
        const helpIndex = args.findIndex(a => a === '--help' || a === '-h');

        // Show help if requested
        if (helpIndex !== -1) {
          console.log(`
Usage:
  abapgit-agent create

Description:
  Create abapGit online repository in ABAP system.
  Auto-detects URL from git remote and package from .abapGitAgent.

Prerequisites:
  - Run "abapgit-agent init" first
  - Edit .abapGitAgent with credentials (host, user, password)

Examples:
  abapgit-agent create                    # Create repo in ABAP
`);
          return;
        }

        // Get parameters from config
        const config = loadConfig();
        const repoUrl = getGitRemoteUrl();

        if (!repoUrl) {
          console.error('Error: No git remote configured. Please configure a remote origin.');
          process.exit(1);
        }

        if (!config.package) {
          console.error('Error: Package not configured. Run "abapgit-agent init" first or set package in .abapGitAgent.');
          process.exit(1);
        }

        const branch = getGitBranch();

        // Extract repo name from git URL
        const repoName = repoUrl.split('/').pop().replace('.git', '');

        console.log(`\nüöÄ Creating online repository`);
        console.log(`   URL: ${repoUrl}`);
        console.log(`   Package: ${config.package}`);
        console.log(`   Folder: ${config.folder || '/src/'}`);
        console.log(`   Name: ${repoName}`);
        console.log(`   Branch: ${branch}`);

        const csrfToken = await fetchCsrfToken(config);

        const data = {
          url: repoUrl,
          package: config.package,
          name: repoName,
          branch: branch,
          folder: config.folder || '/src/'
        };

        if (config.gitUsername) {
          data.username = config.gitUsername;
        }

        if (config.gitPassword) {
          data.password = config.gitPassword;
        }

        const result = await request('POST', '/sap/bc/z_abapgit_agent/create', data, { csrfToken });

        console.log('\n');

        // Handle uppercase keys from ABAP
        const success = result.SUCCESS || result.success;
        const repoKey = result.REPO_KEY || result.repo_key;
        const createdRepoName = result.REPO_NAME || result.repo_name;
        const message = result.MESSAGE || result.message;
        const error = result.ERROR || result.error;

        if (success === 'X' || success === true) {
          console.log(`‚úÖ Repository created successfully!`);
          console.log(`   URL: ${repoUrl}`);
          console.log(`   Package: ${config.package}`);
          console.log(`   Name: ${createdRepoName || repoName}`);
        } else {
          console.log(`‚ùå Failed to create repository`);
          console.log(`   Error: ${error || message || 'Unknown error'}`);
          process.exit(1);
        }
        break;
      }

      case 'import': {
        const helpIndex = args.findIndex(a => a === '--help' || a === '-h');

        // Show help if requested
        if (helpIndex !== -1) {
          console.log(`
Usage:
  abapgit-agent import [--message <message>]

Description:
  Import existing objects from package to git repository.
  Uses the git remote URL to find the abapGit online repository.

Prerequisites:
  - Run "abapgit-agent create" first or create repository in abapGit UI
  - Package must have objects to import

Options:
  --message    Commit message (default: "feat: initial import from ABAP package <package>")

Examples:
  abapgit-agent import
  abapgit-agent import --message "Initial import from SAP"
`);
          return;
        }

        // Get parameters from config
        const config = loadConfig();
        const repoUrl = getGitRemoteUrl();

        if (!repoUrl) {
          console.error('Error: No git remote configured. Please configure a remote origin.');
          process.exit(1);
        }

        const messageArgIndex = args.indexOf('--message');
        let commitMessage = null;
        if (messageArgIndex !== -1 && messageArgIndex + 1 < args.length) {
          commitMessage = args[messageArgIndex + 1];
        }

        console.log(`\nüì¶ Importing objects to git repository`);
        console.log(`   URL: ${repoUrl}`);
        if (commitMessage) {
          console.log(`   Message: ${commitMessage}`);
        }

        const csrfToken = await fetchCsrfToken(config);

        const data = {
          url: repoUrl
        };

        if (commitMessage) {
          data.message = commitMessage;
        }

        if (config.gitUsername) {
          data.username = config.gitUsername;
        }

        if (config.gitPassword) {
          data.password = config.gitPassword;
        }

        const result = await request('POST', '/sap/bc/z_abapgit_agent/import', data, { csrfToken });

        console.log('\n');

        // Handle uppercase keys from ABAP
        const success = result.SUCCESS || result.success;
        const filesStaged = result.FILES_STAGED || result.files_staged;
        const abapCommitMessage = result.COMMIT_MESSAGE || result.commit_message;
        const error = result.ERROR || result.error;

        if (success === 'X' || success === true) {
          console.log(`‚úÖ Objects imported successfully!`);
          console.log(`   Files staged: ${filesStaged}`);
          console.log(`   Commit: ${commitMessage || abapCommitMessage}`);
        } else {
          console.log(`‚ùå Import failed`);
          console.log(`   Error: ${error || resultMessage || 'Unknown error'}`);
          process.exit(1);
        }
        break;
      }

      case 'pull':
        const urlArgIndex = args.indexOf('--url');
        const branchArgIndex = args.indexOf('--branch');
        const filesArgIndex = args.indexOf('--files');
        const transportArgIndex = args.indexOf('--transport');

        // Auto-detect git remote URL if not provided
        let gitUrl = urlArgIndex !== -1 ? args[urlArgIndex + 1] : null;
        let branch = branchArgIndex !== -1 ? args[branchArgIndex + 1] : getGitBranch();
        let files = null;
        let transportRequest = null;

        if (filesArgIndex !== -1 && filesArgIndex + 1 < args.length) {
          files = args[filesArgIndex + 1].split(',').map(f => f.trim());
        }

        if (transportArgIndex !== -1 && transportArgIndex + 1 < args.length) {
          transportRequest = args[transportArgIndex + 1];
        }

        if (!gitUrl) {
          gitUrl = getGitRemoteUrl();
          if (!gitUrl) {
            console.error('Error: Not in a git repository or no remote configured.');
            console.error('Either run from a git repo, or specify --url <git-url>');
            process.exit(1);
          }
          console.log(`üìå Auto-detected git remote: ${gitUrl}`);
        }

        await pull(gitUrl, branch, files, transportRequest);
        break;

      case 'health':
        await healthCheck();
        break;

      case 'status':
        if (isAbapIntegrationEnabled()) {
          console.log('‚úÖ ABAP Git Agent is ENABLED');
          console.log('   Config location:', pathModule.join(process.cwd(), '.abapGitAgent'));
        } else {
          console.log('‚ùå ABAP Git Agent is NOT configured');
        }
        break;

      case 'inspect': {
        // TODO: Implement full inspect feature with:
        // - Syntax check (currently implemented via /inspect)
        // - Code Inspector checks (SE51, SCI)
        // - ATC checks (SATC)
        // - Custom rule checks
        // Add --check-type parameter to specify which check to run

        const filesArgIndex = args.indexOf('--files');
        if (filesArgIndex === -1 || filesArgIndex + 1 >= args.length) {
          console.error('Error: --files parameter required');
          console.error('Usage: abapgit-agent inspect --files <file1>,<file2>,...');
          console.error('Example: abapgit-agent inspect --files zcl_my_class.clas.abap');
          process.exit(1);
        }

        const filesSyntaxCheck = args[filesArgIndex + 1].split(',').map(f => f.trim());

        console.log(`\n  Inspect for ${filesSyntaxCheck.length} file(s)`);
        console.log('');

        const config = loadConfig();
        const csrfToken = await fetchCsrfToken(config);

        for (const sourceFile of filesSyntaxCheck) {
          await syntaxCheckSource(sourceFile, csrfToken, config);
        }
        break;
      }

      case 'unit': {
        const filesArgIndex = args.indexOf('--files');
        if (filesArgIndex === -1 || filesArgIndex + 1 >= args.length) {
          console.error('Error: --files parameter required');
          console.error('Usage: abapgit-agent unit --files <file1>,<file2>,...');
          console.error('Example: abapgit-agent unit --files zcl_my_test.clas.abap');
          process.exit(1);
        }

        const files = args[filesArgIndex + 1].split(',').map(f => f.trim());

        console.log(`\n  Running unit tests for ${files.length} file(s)`);
        console.log('');

        const config = loadConfig();
        const csrfToken = await fetchCsrfToken(config);

        for (const sourceFile of files) {
          await runUnitTestForFile(sourceFile, csrfToken, config);
        }
        break;
      }

      case 'tree': {
        const packageArgIndex = args.indexOf('--package');
        if (packageArgIndex === -1 || packageArgIndex + 1 >= args.length) {
          console.error('Error: --package parameter required');
          console.error('Usage: abapgit-agent tree --package <package> [--depth <n>] [--include-objects] [--json]');
          console.error('Example: abapgit-agent tree --package $ZMY_PACKAGE');
          process.exit(1);
        }

        const packageName = args[packageArgIndex + 1];

        // Optional depth parameter
        const depthArgIndex = args.indexOf('--depth');
        let depth = 3;
        if (depthArgIndex !== -1 && depthArgIndex + 1 < args.length) {
          depth = parseInt(args[depthArgIndex + 1], 10);
          if (isNaN(depth) || depth < 1) {
            console.error('Error: --depth must be a positive number');
            process.exit(1);
          }
        }

        // Optional include-objects parameter
        const includeObjects = args.includes('--include-objects');

        // Optional json parameter
        const jsonOutput = args.includes('--json');

        if (jsonOutput) {
          const config = loadConfig();
          const csrfToken = await fetchCsrfToken(config);
          const result = await runTreeCommand(packageName, depth, includeObjects, csrfToken, config);
          console.log(JSON.stringify(result, null, 2));
        } else {
          await displayTreeOutput(packageName, depth, includeObjects);
        }
        break;
      }

      case 'view': {
        const objectsArgIndex = args.indexOf('--objects');
        if (objectsArgIndex === -1 || objectsArgIndex + 1 >= args.length) {
          console.error('Error: --objects parameter required');
          console.error('Usage: abapgit-agent view --objects <obj1>,<obj2>,... [--type <type>] [--json]');
          console.error('Example: abapgit-agent view --objects ZCL_MY_CLASS');
          console.error('Example: abapgit-agent view --objects ZCL_CLASS1,ZCL_CLASS2 --type CLAS');
          process.exit(1);
        }

        const objects = args[objectsArgIndex + 1].split(',').map(o => o.trim());
        const typeArg = args.indexOf('--type');
        const type = typeArg !== -1 ? args[typeArg + 1] : null;
        const jsonOutput = args.includes('--json');

        console.log(`\n  Viewing ${objects.length} object(s)`);

        const config = loadConfig();
        const csrfToken = await fetchCsrfToken(config);

        const data = {
          objects: objects
        };

        if (type) {
          data.type = type;
        }

        const result = await request('POST', '/sap/bc/z_abapgit_agent/view', data, { csrfToken });

        // Handle uppercase keys from ABAP
        const success = result.SUCCESS || result.success;
        const viewObjects = result.OBJECTS || result.objects || [];
        const message = result.MESSAGE || result.message || '';
        const error = result.ERROR || result.error;

        if (!success || error) {
          console.error(`\n  Error: ${error || 'Failed to view objects'}`);
          break;
        }

        if (jsonOutput) {
          console.log(JSON.stringify(result, null, 2));
        } else {
          console.log(`\n  ${message}`);
          console.log('');

          for (let i = 0; i < viewObjects.length; i++) {
            const obj = viewObjects[i];
            const objName = obj.NAME || obj.name || `Object ${i + 1}`;
            const objType = obj.TYPE || obj.type || '';
            const objTypeText = obj.TYPE_TEXT || obj.type_text || '';
            const description = obj.DESCRIPTION || obj.description || '';
            const methods = obj.METHODS || obj.methods || [];
            const components = obj.COMPONENTS || obj.components || [];

            console.log(`  üìñ ${objName} (${objTypeText})`);
            if (description) {
              console.log(`     ${description}`);
            }

            // Display source code for classes and interfaces
            const source = obj.SOURCE || obj.source || '';
            if (source && (objType === 'INTF' || objType === 'Interface' || objType === 'CLAS' || objType === 'Class')) {
              console.log('');
              // Replace escaped newlines with actual newlines and display
              const displaySource = source.replace(/\\n/g, '\n');
              const lines = displaySource.split('\n');
              for (const line of lines) {
                console.log(`  ${line}`);
              }
            }

            if (methods.length > 0) {
              console.log(`     Methods: ${methods.length}`);
              for (const method of methods.slice(0, 5)) {
                const name = method.NAME || method.name || '';
                const visibility = method.VISIBILITY || method.visibility || '';
                console.log(`       - ${visibility} ${name}`);
              }
              if (methods.length > 5) {
                console.log(`       ... and ${methods.length - 5} more`);
              }
            }

            if (components.length > 0) {
              // Check if this is a data element (DTEL) - show domain info in property format
              if (objType === 'DTEL' || objType === 'Data Element') {
                const propWidth = 18;
                const valueWidth = 40;

                // Build separator with corners
                const sep = '‚îå' + '‚îÄ'.repeat(propWidth + 2) + '‚î¨' + '‚îÄ'.repeat(valueWidth + 2) + '‚îê';
                const mid = '‚îú' + '‚îÄ'.repeat(propWidth + 2) + '‚îº' + '‚îÄ'.repeat(valueWidth + 2) + '‚î§';
                const end = '‚îî' + '‚îÄ'.repeat(propWidth + 2) + '‚î¥' + '‚îÄ'.repeat(valueWidth + 2) + '‚îò';

                // Helper to build row
                const buildPropRow = (property, value) => {
                  return '‚îÇ ' + String(property || '').padEnd(propWidth) + ' ‚îÇ ' +
                         String(value || '').substring(0, valueWidth).padEnd(valueWidth) + ' ‚îÇ';
                };

                console.log(`  DATA ELEMENT ${objName}:`);
                console.log(sep);
                console.log(buildPropRow('Property', 'Value'));
                console.log(mid);

                // Collect properties from top-level fields and components
                const domain = obj.DOMAIN || obj.domain || '';
                const domainType = obj.DOMAIN_TYPE || obj.domain_type || '';
                const domainLength = obj.DOMAIN_LENGTH || obj.domain_length || 0;
                const domainDecimals = obj.DOMAIN_DECIMALS || obj.domain_decimals || 0;
                const description = obj.DESCRIPTION || obj.description || '';

                if (domainType) {
                  console.log(buildPropRow('Data Type', domainType));
                }
                if (domainLength) {
                  console.log(buildPropRow('Length', String(domainLength)));
                }
                if (domainDecimals) {
                  console.log(buildPropRow('Decimals', String(domainDecimals)));
                }
                if (description) {
                  console.log(buildPropRow('Description', description));
                }
                if (domain) {
                  console.log(buildPropRow('Domain', domain));
                }

                console.log(end);
              } else {
                // Build table display for TABL/STRU with Data Element and Description
                const colWidths = {
                  field: 16,      // Max field name length
                  key: 3,
                  type: 8,
                  length: 8,
                  dataelement: 30, // Max data element name length
                  description: 60, // Max field description length
                };

                // Helper to truncate with ellipsis if needed
                const truncate = (str, maxLen) => {
                  const s = String(str || '');
                  if (s.length <= maxLen) return s;
                  return s.substring(0, maxLen - 1) + '‚Ä¶';
                };

                // Helper to build row
                const buildRow = (field, key, type, length, dataelement, description) => {
                  return '  | ' + truncate(field, colWidths.field).padEnd(colWidths.field) + ' | ' + String(key || '').padEnd(colWidths.key) + ' | ' + truncate(type, colWidths.type).padEnd(colWidths.type) + ' | ' + String(length || '').padStart(colWidths.length) + ' | ' + truncate(dataelement, colWidths.dataelement).padEnd(colWidths.dataelement) + ' | ' + truncate(description, colWidths.description).padEnd(colWidths.description) + ' |';
                };

                // Build separator line (matches row structure with | at ends and + between columns)
                const sep = '  |' + '-'.repeat(colWidths.field + 2) + '+' +
                            '-'.repeat(colWidths.key + 2) + '+' +
                            '-'.repeat(colWidths.type + 2) + '+' +
                            '-'.repeat(colWidths.length + 2) + '+' +
                            '-'.repeat(colWidths.dataelement + 2) + '+' +
                            '-'.repeat(colWidths.description + 2) + '|';

                // Header
                console.log(`  TABLE ${objName}:`);
                console.log(sep);
                console.log(buildRow('Field', 'Key', 'Type', 'Length', 'Data Elem', 'Description'));
                console.log(sep);

                // Rows
                for (const comp of components) {
                  const key = comp.KEY || comp.key || false ? 'X' : '';
                  const dataelement = comp.DATAELEMENT || comp.dataelement || '';
                  const description = comp.DESCRIPTION || comp.description || '';
                  console.log(buildRow(comp.FIELD || comp.field, key, comp.TYPE || comp.type, comp.LENGTH || comp.length, dataelement, description));
                }

                console.log(sep);
              }
            }

            console.log('');
          }

        }
        break;
      }

      case 'help':
      case '--help':
      case '-h':
        console.log(`
ABAP Git Agent

Usage:
  abapgit-agent <command> [options]

Commands:
  init --folder <folder> --package <package>
    Initialize local configuration for an existing git repository.

  create
    Create abapGit online repository in ABAP system.
    Auto-detects URL from git remote and package from .abapGitAgent.

  import [--message <message>]
    Import existing objects from package to git repository.
    Uses the git remote URL to find the abapGit online repository.

  pull [--url <git-url>] [--branch <branch>] [--files <file1,file2,...>] [--transport <request>]
    Pull and activate repository in ABAP system.
    Auto-detects git remote and branch from current directory.
    Use --files to pull only specific files.
    Use --transport to specify a transport request.

  inspect --files <file1>,<file2>,...
    Inspect ABAP source file(s) for issues. Currently runs syntax check.

  unit --files <file1>,<file2>,...
    Run AUnit tests for ABAP test class files (.testclasses.abap)

  tree --package <package> [--depth <n>] [--include-objects] [--json]
    Display package hierarchy tree from ABAP system

  view --objects <obj1>,<obj2>,... [--type <type>] [--json]
    View ABAP object definitions from the ABAP system

  health
    Check if ABAP REST API is healthy

  status
    Check if ABAP integration is configured for this repo

Examples:
  abapgit-agent init --folder /src --package ZMY_PACKAGE      # Initialize
  abapgit-agent create                                       # Create repo
  abapgit-agent import                                       # Import objects to git
  abapgit-agent import --message "Initial import"            # Import with message
  abapgit-agent pull                                         # Auto-detect from git
  abapgit-agent pull --branch develop                        # Specific branch
  abapgit-agent pull --files zcl_my_class.clas.abap          # Specific file
  abapgit-agent pull --transport DEVK900001                  # With transport
  abapgit-agent inspect --files zcl_my_class.clas.abap       # Syntax check
  abapgit-agent unit --files zcl_my_test.clas.testclasses.abap  # Run tests
  abapgit-agent tree --package $ZMY_PACKAGE                      # Show package tree
  abapgit-agent tree --package $ZMY_PACKAGE --depth 2             # Shallow tree
  abapgit-agent tree --package $ZMY_PACKAGE --include-objects     # With object counts
  abapgit-agent tree --package $ZMY_PACKAGE --json                # JSON output
  abapgit-agent view --objects ZCL_MY_CLASS                       # View class definition
  abapgit-agent view --objects ZIF_MY_INTERFACE --type INTF       # View interface
  abapgit-agent view --objects ZMY_TABLE --type TABL               # View table structure
  abapgit-agent view --objects ZCL_CLASS1,ZCL_CLASS2 --json        # Multiple objects
  abapgit-agent health
  abapgit-agent status
`);
        break;

      default:
        console.error(`Unknown command: ${command}`);
        console.error('Use: abapgit-agent help');
        process.exit(1);
    }
  } catch (error) {
    console.error(`Error: ${error.message}`);
    process.exit(1);
  }
}

main();
